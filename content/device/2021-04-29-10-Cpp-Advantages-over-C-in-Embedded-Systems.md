---
categories:
- Device Tips
date: "2021-04-29"
layout: post
tags:
- microcontroller
- cpp
- programming
title: 10 C++ Advantages over C in Embedded Systems
---

I have been using C++ to program microcontrollers for over 10 years now. What first motiviated me to start using C++ was that I was tired of re-writing and maintaining the same code for slightly different use cases in C. But over time, I have found some really big advantages of C++ over C. So much so, that I claim the jump from C to C++ is almost as substantial as asm to C.

Here are 10 advantages of C++ over C for everyday microcontroller programming.

- Object-Oriented Programming (OOP)
- Object-Oriented Interface Reuse
- Template Programming
- RAII
- Stronger Types
- Polymorphism
- constexpr
- References
- namespaces
- Symbol Mangling

## 1. Object Oriented Programming

Object-oriented programming can be done in C. It just ends up being really tedious. If we look at a POSIX mutex we can see this. This pattern of passing an object pointer is extremely common (and tedious) in C.

```c++
//C
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);

//usage
pthread_mutex_t mutex0;

//passing the argument leaves room for error and bugs
pthread_mutex_lock(&mutex0); 
```

In C++, the compiler will manage the data object for you. Consider this Mutex class.

```c++
class Mutex {
  int lock(){
    return pthread_mutex_lock(&m_mutex);
  }
  int unlock(){
    return pthread_mutex_unlock(&m_mutex);
  }
private:
  pthread_mutex_t m_mutex;
};

//usage
Mutex mutex0;
mutex0.lock(); //impossible to pass the wrong value
```

What you get with C++ is more concise code that is less prone to programming mistakes. If you multiply this simple approach by thousands of lines of code. You get a HUGE improvement.

## 2. Object Oriented Interface Re-use


## 3. Template Programming

In C++, you can use templates to have variable types for a function. Consider this digital filter:

```c++
//C
typedef struct {
  int average;
  int weight;
} filter_t;
int filter(filter_t * filter, int input);
```

What if I wanted an `int` version of the filter and a `float` version? C requires you to have two copies of the same code (or do a crazy preprocessor macro). C++ has templates.

```c++
template<typename NumberType> class Filter {
public:
  NumberType filter(NumberType input){
    //implement here
  }

private:
  NumberType m_average;
  NumberType m_weight;
};

Filter<float> f_filter;
Filter<int> i_filter;
```

## 4. RAII

## 5. Stronger Types

## 6. Polymorphism

## 7. `constexpr`

In C, the use of pre-processor macros is abundant. And for C, it is generally good practice. However, it can be a big pain to debug and causes scoping problems.

C++ has a `constexpr` keyword that allows you to tell the compiler that that value should be evaluated at compile time.

## 8. References

## 9. Symbol Scoping

In C, you end up doing a lot of manually prefixing. I usually do something like this for example, `logic.h`.

```c
int logic_initialize(void * logic_object);
int logic_finalize(void * logic_object);
int logic_read(void * logic_object, void * buffer, int nbyte);
int logic_write(void * logic_object);
```



## 10. Symbol Mangling

In C, object level symbols are generated by function name, but C++ accounts for both the name of the function its arguments. It creats a `mangled` symbol that is unique. This is fantastic for designing APIs. Consider these examples:

```c++
//C
int write(const void * buffer, int nbyte);
int write_location(int loc, const void * buffer, int nbyte);

//C++
int write(const void * buffer, int nbyte);
int write(int loc, const void * buffer, int nbyte);
```